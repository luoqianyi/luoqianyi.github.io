# 计算机组成原理面试题

## 什么是冯诺伊曼结构 ⭐

输入输出，计算单元，控制单元，存储单元。

## 计算机硬件系统由哪几部分组成

计算机硬件系统由运算器、控制器、存储器、输入和输出 5 大部分组成。

## 简要的介绍冯诺依曼计算机

（1）计算机硬件系统由运算器、控制器、存储器、输入和输出 5 大部分组成。

（2）指令和数据以同等地位存于存储器中，并按地址寻访。

（3）指令和数据均用二进制代码表示。

（4）指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。

（5）指令在存储器内按顺序存放，通常，指令是顺序执行的，在特定的条件下，可根据运算结果或根据设定的条件改变执行顺序。

（6）早期的冯诺依曼计算机以运算器为中心，输入 / 输出设备通过运算器与存储器交换信息。

## 指令系统 ⭐

CISC 复杂指令集，RISC 是精简指令集。

## 简述 CISC

CISC（Complex Instruction Set Computer）：复杂指令系统计算机

（1）指令系统复杂庞大，指令长度不固定，指令格式多，寻址方式多。

（2）可以访存的指令不受限制，各种指令使用的相差频度大，执行时间相差大。

（3）采用微程序控制，难以用优化编译生成高效的目标代码程序。

## 简述 RISC

RISC（Reduced Instruction Set Computer）：精简指令系统计算机

（1）选取使用频率最高的一些简单指令，复杂指令由简单指令构成

（2）指令长度固定，指令格式种类少，寻址方式种类少

（3）只有取数存数指令访存

（4）CPU 中通用寄存器数量多

（5）采用流水线

（6）硬布线 特别注意编译优化

## CISC 和 RISC 的比较 ⭐

|                                                              | CISC（**复杂指令集计算机**）                       | RISC（**简单指令集计算机**）                                 |
| ------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ |
| 指令系统指令数寻址方式可访存指令各种指令使用频率各种指令执行时间 | 复杂,庞大一般大于200不固定不加限制相差很大相差很大 | 简单,精简一般小于100固定32位只有LOAD/STORE指令相差不大绝大多数在一个机器周期完成 |
| 优化编译实现                                                 | 很难                                               | 较容易                                                       |
| 程序源代码长度                                               | 较短                                               | 较长                                                         |
| 控制逻辑实现方式                                             | 绝大多数为微程序控制                               | 绝大多数为硬连线控制，应用流水线技术                         |
|                                                              |                                                    | RISC机的主要优点可归纳如下①充分利用VLSI芯片的面积②提高了计算机运行速度③便于设计,降低成本,提高可靠性④有效支持高级语言程序 |



## IEEE754 标准

|          | 符号位 S | 阶码 | 尾数 | 总位数 |
| -------- | -------- | ---- | ---- | ------ |
| 短实数   | 1        | 8    | 23   | 32     |
| 长实数   | 1        | 11   | 52   | 64     |
| 临时实数 | 1        | 15   | 64   | 80     |

根据 IEEE 754 国际标准，常用的浮点数有三种格式:

单精度格式 32 位，阶码为 8 位，尾数为 23 位。另有一位符号位 S，处在最高位.

由于 IEEE754 标准约定在小数点左部有一位隐含位，从而实际有效位数为 24 位。这样使得尾数的有效值变为 1。

阶码部分采用移码表示，移码值 127，1 到 254 经移码为 -126 到 +127。

| S(1位) | E(8位)     | M(23位) | N(共32位)                      |
| ------ | ---------- | ------- | ------------------------------ |
| 符号位 | 0          | 0       | 0                              |
| 符号位 | 0          | 不等于0 | (-1)S·2-126·(0.M) 为非规格化数 |
| 符号位 | 1到254之间 | -       | (-1)S·2E-127·(1.M) 为规格化数  |
| 符号位 | 255        | 不等于0 | NaN(非数值)                    |
| 符号位 | 255        | 0       | 无穷大                         |

0 有了精确的表示,无穷大也明确表示.对于绝对值较小的数,可以采用非规格化数表示,减少下溢精度损失.非规格化数的隐含位是 0，不是 1

## 程序访问的局部性

时间局部性：如果一个存储项被访问，则可能该项会很快被再次访问

空间局部性：如果一个存储项被访问，则该项及其邻近的项也可能很快被访问

## 编译与解释

计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。

翻译的方式有两种，一个是编译，一个是解释。

* 编译型语言写的程序在执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如 exe 文件，如果源程序不变以后要运行的话就不用重新翻译。

* 解释则不同，解释性语言的程序不需要编译，在运行程序的时候才翻译，翻译一句执行一句，不生成目标程序，这样解释性语言每执行一次就要翻译一次，效率比较低。

java文件->编译->.class文件，编译成.class字节码,.class需要jvm解释，然后解释执行。Java很特殊，Java程序需要编译但是没有直接编译成机器语言，即二进制语言，而是编译成字节码（.class）再用解释方式执行。java程序编译以后的class属于中间代码，并不是可执行程序exe，不是二进制文件，所以在执行的时候需要一个中介来解释中间代码，这就是所谓的java虚拟机（JVM），也叫JDK。

C语言编译过程分成四个步骤：

1， 由.c文件到.i文件，这个过程叫预处理

将#include包含的头文件直接拷贝到hell.c当中；将#define定义的宏进行替换，同时将代码中没用的注释部分删除等

2， 由.i文件到.s文件，这个过程叫编译

3， 由.s文件到.o文件，这个过程叫汇编

高级语言->汇编语言->机器语言

4， 由.o文件到可执行文件，这个过程叫链接

将翻译成的二进制与需要用到库绑定在一块

## 字长

机器字长：计算机能直接处理的二进制位数

指令字长：一个指令字中包含的二进制代码位数

存储字长：一个存储单元存储二进制代码长度

CPI：执行一条指令需要的时钟周期数

## cache 和寄存器区别 ⭐

寄存器是暂时存储的 CPU 组成部分，cache 用来做高度 CPU 和低速的主存之间加速带。

## Cache 的基本工作原理

Cache 通常由两部分组成：块表和快速存储器

其工作原理是：处理机按主存地址访问存储器，存储器地址的高段通过主存-Cache 地址映射机构借助查块表判定该地址的存储单元是否在 Cache 中，如果在，则 Cache 命中，按 Cache 地址访问 Cache。否则，Cache 不命中，则需要访问主存，并从主存中调入相应数据块到 Cache 中，若 Cache 中已写满，则要按某种算法将 Cache 中的某一块替换出去，并修改有关的地址映射关系。

## Cache 和主存之间的映射方式

直接映射就是将主存地址映射到Cache中的一个指定地址.任何时候,主存中存储单元的数据只能调入到Cache中的一个位置,这是固定的,若这个位置已有数据,则产生冲突,原来的块将无条件地被替换出去.

全相联映射就是任何主存地址可映射到任何Cache地址的方式.在这种方式下,主存中存储单元的数据可调入到Cache中的任意位置.只有在Cache中的块全部装满后才会出现块冲突.

组相联映射指的是将存储空间的页面分成若干组,各组之间的直接映射,而组内各块之间则是全相联映射.

##  Cache 中主存块的替换算法

|                   | 思想                                             | 优点                                                 | 缺点                                                         |
| ----------------- | ------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| 随机算法RAND      | 用软的或硬的随机数产生器产生上层中要被替换的页号 | 简单,易于实现                                        | 没有利用上层存储器使用的"历史信息",没有反映等程序局部性,命中率低. |
| 先进先出FIFO      | 选择最早装入上层的页作为被替换的页               | 实现方便,利用了主存历史的信息                        | 不能正确反映程序局部性原理,命中率不高,可能出现一种异常现象.  |
| 近期最少使用法LRU | 选择近期最少访问的页作为被替换的页               | 比较正确反映程序局部性,利用访存的历史信息,命中率较高 | 实现较复杂                                                   |
| 优化替换算法OPT   | 将未来近期不用的页换出去                         | 命中率最高,可作为衡量其他替换算法的标准              | 不现实,只是一种理想算法                                      |

## 虚拟存储器的基本概念

虚拟存储器是指具有请求调入和置换功能，能从逻辑上对内存容量加以扩存的一种存储器系统

## 页式虚拟存储器

页式管理:是把虚拟存储空间和实际空间等分成固定大小的页,各虚拟页可装入主存中的不同实际页面位置.页式存储中,处理机逻辑地址由虚页号和页内地址两部分组成,实际地址也分为页号和页内地址两部分,由地址映射机构将虚页号转换成主存的实际页号.

页式管理用一个页表,包括页号,每页在主存中起始位置,装入位等.页表是虚拟页号与物理页号的映射表.页式管理由操作系统进行,对应用程序员的透明的.

## 段式虚拟存储器

段式管理: 把主存按段分配的存储管理方式.它是一种模块化的存储管理方式,每个用户程序模块可分到一个段,该程序模块只能访问分配给该模块的段所对应的主存空间.段长可以任意设定,并可放大和缩小.

系统中通过一个段表指明各段在主存中的位置.段表中包括段名(段号),段起点,装入位和段长等.段表本身也是一个段.段一般是按程序模块分的.

## 段页式虚拟存储器

段页式管理:是上述两种方法的结合,它将存储空间按逻辑模块分成段,每段又分成若干个页,访存通过一个段表和若干个页表进行.段的长度必须是页长的整数倍,段的起点必须是某一页的起点.

## TLB(快表)

在虚拟存储器中进行地址变换时,需要虚页号变换成主存中实页号的内部地址变换,这一过程

缓存时首先要到主存查页表，然后才能根据主存物理地址访问主存的存取指令或数据。因此采用虚拟存储器机制后，访存的次数增加了。为了减少访存的次数，往往将页表中最活跃的几个页表项复制到高速缓存中。这种在高速缓存中的页表项称为快表（translation look aside buffer）

查表时,根据虚页表同时查找快表和慢表,当在快表中查到该虚页号时,就能很快找到对应的实页号,将其送入主存实地址寄存器,同时使慢表的查找作废,这时主存的访问速度没降低多少.如果在快表中查不到,则经过一个访主存的时间延迟后,将从慢表中查到的实页送入实地址寄存器,同时将此虚页号和对应的实页号送入快表

## 指令的执行过程

读取指令

​        指令地址(在PC中)送到地址寄存器            

​        读主存,读出内容(指令代码)送入指令寄存器IR

 

​     分析指令

​         形成下一条指令的地址并送到PC中

 

​     执行指令

​        用一到几个执行步骤,完成指令的运算、操作功能,

​        不同的指令操作步骤和具体运算、操作功能各不相同    

​     检查有无中断请求

​        无中断请求、进入下一条指令的执行过程

## 指令流水线的基本概念 ⭐

(1)流水线基本原理

流水线技术是一种显著提高指令执行速度与效率的技术.方法是:指令取指完成后,不等该指令执行完毕即可取下一条指令.

如果把一条指令的解释过程进一步细分,例如分成取指,译码, 访存，执行,和写回五个子过程,并用五个子部件分别处理这五个子过程.这样只需在上一指令的第一子过程处理完毕进入第二子过程处理时,在第一子部件中就开始对第二条指令的第一子过程进行处理.随着时间推移,这种重叠操作最后可达到五个子部件同时对五条指令的子过程进行操作.

(2)影响流水线性能的因素

l 结构相关是当多条同一时刻争用同一资源形成冲突

² 暂停一个时钟周期

² 单独设置数据存储器和指令存储器

l 数据相关是指令在流水线中重叠执行时,当后继指令需要用到前面指令的执行结果时发生的.

² 暂停时钟周期

² 数据旁路：把前一条指令的ALU计算结果直接输入到下一条指令

l 控制相关是当流水线遇到分支指令和其他改变PC值的指令时引起的.

## RAID 分类

其原理是将并行处理原理引入磁盘系统.它采用低成本的小温盘,使多台磁盘构成同步化的磁盘阵列,数据展开存储在多台磁盘上,提高了数据传输的带宽,并利用冗余技术提高可靠性

RAID-0级采用无冗余无校验，数据分布在多个物理磁盘.

RAID-1级采用磁盘镜像阵列技术.

RAID-2级采用海明纠错码的磁盘阵列,通过增加校验磁盘实现单纠错双检错功能.

RAID-3级是采用奇偶校验冗余的磁盘阵列,它也采用数据位交叉,阵列中只用一个校验盘.

RAID-4级是一种独立传送磁盘阵列,它采用数据块交叉,用一个校验盘.

RAID-5也是一种独立传送磁盘阵列,它采用数据块交叉和分布的冗余校验,将数据和校验位都分布在各磁盘中,没有专门的奇偶校验驱动器.

##  I/O 方式 ⭐

**1. 程序查询方式**

程序查询方式的核心问题是每时每刻需要不断查询I/O设备是否准备好.CPU不断地询问外设是否准备好:如果准备好,CPU执行IO操作;否则,CPU一直等待.CPU大部分时间处于等待状态,利用率不高.

**2. 程序中断方式**

 **中断处理过程**

中断处理过程可分以下几个步骤:

请求中断→响应中断→关闭中断→保留断点→中断源识别→保护现场→中断服务子程序→恢复现场→中断返回

**3. DMA方式**

DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。

| DMA 方式与程序中断方式的比较 |                  |                  |
| ---------------------------- | ---------------- | ---------------- |
|                              | **中断方式**     | **DMA方式**      |
| **(1) 数据传送**             | **程序**         | **硬件**         |
| **(2) 响应时间**             | **指令执行结束** | **存取周期结束** |
| **(3) 处理异常情况**         | **能**           | **不能**         |
| **(4) 中断请求**             | **传送数据**     | **后处理**       |
| **(5) 优先级**               | **低**           | **高**           |





